# What is the Smallest Possible .EXE? | Inkbox(11분 30초정도 부터 나옴)
- Windows에서 키 2번 눌리는 버그 해결하는거 찾음
  - https://youtu.be/5_UCkcb7iGY?si=dHWzwRQMOxNn_1eS


- cursor input, or the only thing I am interested in, key events, which will then attach a key event record structure that contains what I'm looking for, the ASCII character of the keyboard input. Now let me test if this code is working correctly here. It should echo whatever the user types back out onto the console. Okay, and that works twice as well as I expected. It looks like the issue here is that there is a key event for both pressing the key and releasing the key, so I have to check this part of the key event record that tells us whether the key is being held down or released, and that's more like it now. Although it is a little sketchy since the non-ASCII keys are also outputting character data. Here's the output of the character chart from 0 to 255 for reference, but that shouldn't be anything to worry about since I'm not actually going to be outputting anything the user types anyways. I'm just checking whether the user presses the left or right arrow keys and then moving the player along.
ChatGPT
  - 커서 입력이나 내가 관심 있는 유일한 것은 키 이벤트입니다. 그런 다음 키보드 입력의 ASCII 문자를 포함하는 키 이벤트 기록 구조체에 연결될 것입니다. 이제 이 코드가 제대로 작동하는지 테스트해 보겠습니다. 사용자가 입력하는 내용을 콘솔에 그대로 출력해야 합니다. 좋아요, 예상보다 두 배 잘 작동하네요. 여기 문제는 키를 누를 때와 뗄 때 모두 키 이벤트가 발생한다는 것입니다. 그래서 키 이벤트 기록의 이 부분을 확인해야 합니다. 키가 눌려 있는지 또는 해제된 상태인지 알려주는 부분입니다. 이제 더 나아졌습니다. 비록 비ASCII 키들도 문자 데이터를 출력하고 있지만요. 여기 0부터 255까지의 문자 차트 출력을 참조하세요. 하지만 사용자가 입력한 내용을 실제로 출력할 계획이 없으므로 걱정할 필요는 없습니다. 나는 단지 사용자가 왼쪽이나 오른쪽 화살표 키를 누르는지 확인하고 플레이어를 이동시키는 것뿐입니다.

- Meteors will move down a layer, and a new layer of meteors will be randomly generated. And without a standard library to just make random numbers magically appear, there are a few options I can go with to implement that same magical functionality by using the Windows API, though none of them are found in the Kernel32 library, but in the Advanced API Services library. One method is to use the Microsoft Cryptography API, but that requires quite a few functions to set up, and I'm trying to keep it minimal, so I'll go with the RTLGenRandom function. Also known as System Function 37, that's literally what I've imported as the program. But all I need to do is specify the destination buffer and how many random bytes I want, and then I can take four random bytes and them with four others to try to save some space between meteors, and then add those to the top layer. Once the meteors reach the bottom layer, I can take these last four bytes, throw them into a single 32-bit register, then roll the bits to the left 32 minus the character's exposition times to load the object at the location the player is standing into the carry flag. Again, zero for the sky, one for the meteor. If it's a one, then the player has been squished by a meteor, and it's, as the kids say, game over. I've added a points counter to the top using four packed BCD bytes, that's two digits zero to nine per byte, and I can make great use of the x86 decimal-adjust-al-after-addition instruction to correctly perform BCD addition. Big thumbs up for Sysk, right guys? This score gets output to the screen every frame, followed by the world and the player. After drawing the frame, checking the input, and running all the game logic, I can use the sleep function to suspend the current thread for a number of specified milliseconds. I have it set to 16 milliseconds for a target of 60 FPS, but of course that doesn't account for program execution time, so it will be slower than that. I could use the getLocalTime function instead to see if 16 milliseconds has passed since the last frame was drawn, but that would cost a few more precious bytes of data. So again, I won't. Once the player is crushed, the program will use my favorite kernel32 function, B, and I just have to read this description from the Microsoft documentation here. A long time ago, all PC computers should have come with an 8254 programmable interval timer chip for the generation of primitive sounds, but then everything changed when the sound cards attacked. I may have added that last part there, but it's still a cool function. You can just drop in the frequency that you want and the duration of the sound, and then you could do something really cool with this function, like make the world's smallest digital piano.
ChatGPT
  - 운석들은 한 층 아래로 이동하고 새로운 층의 운석이 무작위로 생성될 것입니다. 표준 라이브러리를 사용하지 않고 무작위 숫자를 생성하기 위해 몇 가지 옵션이 있는데, 이는 Kernel32 라이브러리가 아닌 Advanced API Services 라이브러리에 있습니다. 한 가지 방법은 Microsoft Cryptography API를 사용하는 것이지만, 많은 함수 설정이 필요하므로 최소화하려는 저는 RTLGenRandom 함수를 사용할 것입니다. 또한 시스템 함수 37로 알려진 이 함수는 프로그램에서 가져온 것입니다. 제가 해야 할 일은 목적지 버퍼와 원하는 무작위 바이트 수를 지정하는 것뿐입니다. 그런 다음 네 개의 무작위 바이트를 네 개의 다른 바이트와 AND 연산하여 운석 간의 간격을 확보하고 이를 상층에 추가합니다. 운석이 하층에 도달하면 마지막 네 바이트를 32비트 레지스터에 넣고, 플레이어가 서 있는 위치에서 비트를 왼쪽으로 32 마이너스 캐릭터의 x 위치만큼 이동하여 캐리 플래그에 객체를 로드합니다. 0은 하늘, 1은 운석입니다. 1이면 플레이어는 운석에 눌려서 게임 오버가 됩니다. 점수 카운터는 네 개의 압축된 BCD 바이트(즉, 바이트당 두 자리 0~9)를 사용하여 상단에 추가했습니다. x86의 DECIMAL-ADJUST-AL-AFTER-ADDITION 명령어를 사용하여 BCD 덧셈을 올바르게 수행할 수 있습니다. Sysk에 큰 박수를, 맞죠? 점수는 매 프레임마다 세계와 플레이어 다음에 화면에 출력됩니다. 프레임을 그린 후 입력을 확인하고 모든 게임 로직을 실행한 다음, sleep 함수를 사용하여 현재 스레드를 지정된 밀리초 동안 일시 중지할 수 있습니다. 이를 16밀리초로 설정하여 60 FPS를 목표로 하지만, 이는 프로그램 실행 시간을 고려하지 않으므로 실제로는 그보다 느릴 것입니다. 대신 getLocalTime 함수를 사용하여 마지막 프레임이 그려진 후 16밀리초가 지났는지 확인할 수 있지만, 이는 몇 바이트의 데이터가 더 소모됩니다. 그래서 하지 않을 것입니다. 플레이어가 으깨지면 프로그램은 제가 가장 좋아하는 kernel32 함수인 Beep를 사용합니다. Microsoft 문서에서 이 설명을 읽어야 합니다. 오래전 모든 PC 컴퓨터에는 원시 사운드 생성을 위한 8254 프로그래머블 인터벌 타이머 칩이 있어야 했지만, 모든 것이 사운드 카드의 공격을 받으면서 변했습니다. 이 마지막 부분은 제가 추가했지만 여전히 멋진 기능입니다. 원하는 주파수와 소리의 지속 시간을 입력하면 정말 멋진 일을 할 수 있습니다. 예를 들어, 세계에서 가장 작은 디지털 피아노를 만들 수 있습니다.

- It's not a good piano, but it is the smallest.
ChatGPT
  - 좋은 피아노는 아니지만, 가장 작은 피아노입니다.

- After assembling with Masm, the program weighs in at 2,448 bytes, and after really trying to cut the fat without breaking the headers, because I do want this to be playable on future systems, I've got it down to 2,358 bytes. And the last piece of the puzzle is another good friend of mine, the crinkler. Crinkler is a compressing linker for Windows. It takes the place of the standard Windows linker, turning our object file into a compressed version of a VXE, which then decompresses when you run it. It's not cheating, because I make up the rules here. So after crinkling my game, it manages to sneak into the under-1k clump at 825 bytes. Here it is after I turned it into a QR code hanging on my fridge. And by the way, the world's smallest piano weighed in at 1,584 bytes before crinkling and 555 bytes afterwards. So the only question I have now is, what is the largest possible VXE? Theoretically, a PE32 file could be no larger than 4 gigabytes, since that's the 32-bit addressing limit. But for jump instructions, it would have to use a signed 32-bit digit, so the limit should be around 2 gigabytes. PE32+, the 64-bit version of the file, does have a special flag to say that it can handle addresses larger than 2 gigabytes. However, once again, we're limited by Windows itself. It doesn't seem to be able to handle executables, both PE32 and PE32+, that are greater than around 1.85 gigabytes. Of course, if you've opened Chrome in the last two years, you'll know that programs can take well over 2 or even 8 gigs of memory. Basically, they'll just take whatever you throw at them. But I'm only talking about Windows loading a large executable. I don't care how big it gets once it's open. And for the record, Chrome.exe is only 2.66 megabytes, Steam.exe is 4.18, Excel.exe is 66, and even Photoshop.exe is only 160 megabytes. As for the exact maximum number of bytes that Windows can take, I simply took one of the last versions of the programs we were shrinking before and threw between 1.8 and 2 gigabytes worth of zeros on the end and did a binary search to find which would load and run and which wouldn't.
ChatGPT
  - 이 프로그램을 Masm으로 어셈블한 후, 크기는 2,448바이트였습니다. 헤더를 손상시키지 않으면서 크기를 줄이려고 노력한 끝에 2,358바이트까지 줄였습니다. 그리고 마지막 퍼즐 조각은 Crinkler입니다. Crinkler는 Windows용 압축 링커로, 표준 Windows 링커를 대신하여 오브젝트 파일을 압축된 VXE로 변환하고 실행 시 압축을 해제합니다. 이게 규칙에 어긋나는 것은 아니고, 제가 규칙을 정하기 때문에 괜찮습니다. Crinkler로 게임을 압축한 결과 825바이트로 줄었고, 이를 QR 코드로 변환하여 냉장고에 붙여 놓았습니다. 그리고 세계에서 가장 작은 피아노는 Crinkler로 압축하기 전 1,584바이트였고, 압축 후 555바이트였습니다.

- 이제 남은 질문은 "가장 큰 가능성 있는 VXE는 무엇인가?"입니다. 이론적으로, PE32 파일은 32비트 주소 지정 제한으로 인해 최대 4기가바이트일 수 있습니다. 하지만 점프 명령을 위해서는 부호 있는 32비트 숫자를 사용해야 하므로, 제한은 약 2기가바이트입니다. PE32+는 64비트 파일 버전으로, 2기가바이트 이상의 주소를 처리할 수 있는 특별한 플래그가 있습니다. 그러나 Windows 자체가 PE32와 PE32+ 실행 파일을 약 1.85기가바이트 이상 처리할 수 없는 것 같습니다. Chrome을 실행해보면 프로그램이 2기가바이트 또는 8기가바이트 이상의 메모리를 사용할 수 있다는 것을 알 수 있습니다. 하지만 저는 Windows가 큰 실행 파일을 로드하는 것에만 관심이 있습니다. Chrome.exe는 2.66메가바이트, Steam.exe는 4.18메가바이트, Excel.exe는 66메가바이트, Photoshop.exe는 160메가바이트입니다. 정확한 최대 바이트 수를 확인하기 위해, 마지막 버전의 프로그램 중 하나에 1.8에서 2기가바이트의 0을 추가하고, 바이너리 검색을 통해 로드 및 실행되는 것과 그렇지 않은 것을 찾아냈습니다.


- 1,996,480,704 bytes, completing the entire range of runnable executables on 64-bit Windows. Thanks once again to Brilliant, check them out down below, and until next time!
ChatGPT
  - 1,996,480,704 바이트, 64비트 Windows에서 실행 가능한 실행 파일의 전체 범위를 완성합니다. 다시 한 번 Brilliant에 감사드리며, 아래 링크를 확인해 주세요. 그럼 다음 시간에 뵙겠습니다!
